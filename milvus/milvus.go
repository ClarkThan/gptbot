package milvus

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/go-aie/gptbot"
	"github.com/go-aie/xslices"
	"github.com/milvus-io/milvus-sdk-go/v2/client"
	"github.com/milvus-io/milvus-sdk-go/v2/entity"
)

const (
	pkName, idName, textName, documentIDName, embeddingName = "pk", "id", "text", "document_id", "embedding"
)

type Config struct {
	// CollectionName is the collection name.
	// This field is required.
	CollectionName string

	// Addr is the address of the Milvus server.
	// Defaults to "localhost:19530".
	Addr string

	// Dim is the embedding dimension.
	// Defaults to 1536 (the dimension generated by OpenAI's Embedding API).
	Dim int
}

func (cfg *Config) init() {
	if cfg.Addr == "" {
		cfg.Addr = "localhost:19530"
	}
	if cfg.Dim == 0 {
		cfg.Dim = 1536
	}
}

type Milvus struct {
	client client.Client
	cfg    *Config
}

func NewMilvus(cfg *Config) (*Milvus, error) {
	cfg.init()
	ctx := context.Background()

	c, err := client.NewGrpcClient(ctx, cfg.Addr)
	if err != nil {
		return nil, err
	}

	m := &Milvus{
		client: c,
		cfg:    cfg,
	}

	_ = m.client.ReleaseCollection(ctx, m.cfg.CollectionName)
	if err := m.createCollectionIfNotExists(ctx); err != nil {
		return nil, err
	}

	return m, nil
}

func (m *Milvus) LoadJSON(ctx context.Context, filename string) error {
	data, err := os.ReadFile(filename)
	if err != nil {
		return err
	}

	var chunks []*gptbot.Chunk
	if err := json.Unmarshal(data, &chunks); err != nil {
		return err
	}

	return m.Upsert(ctx, chunks)
}

func (m *Milvus) Upsert(ctx context.Context, chunks []*gptbot.Chunk) error {
	// We need to release the collection before inserting.
	if err := m.client.ReleaseCollection(ctx, m.cfg.CollectionName); err != nil {
		return err
	}

	var ids []string
	var texts []string
	var documentIDs []string
	var embeddings [][]float32
	for _, chunk := range chunks {
		ids = append(ids, chunk.ID)
		texts = append(texts, chunk.Text)
		documentIDs = append(documentIDs, chunk.DocumentID)
		embeddings = append(embeddings, xslices.Float64ToNumber[float32](chunk.Embedding))
	}

	idCol := entity.NewColumnVarChar(idName, ids)
	textCol := entity.NewColumnVarChar(textName, texts)
	documentIDCol := entity.NewColumnVarChar(documentIDName, documentIDs)
	embeddingCol := entity.NewColumnFloatVector(embeddingName, m.cfg.Dim, embeddings)

	// Create index "IVF_FLAT".
	idx, err := entity.NewIndexIvfFlat(entity.L2, 128)
	if err != nil {
		return err
	}
	if err := m.client.CreateIndex(ctx, m.cfg.CollectionName, embeddingName, idx, false); err != nil {
		return err
	}

	_, err = m.client.Insert(ctx, m.cfg.CollectionName, "", idCol, textCol, documentIDCol, embeddingCol)
	return err
}

// Query searches similarities of the given embedding with default consistency level.
func (m *Milvus) Query(ctx context.Context, embedding gptbot.Embedding, topK int) ([]*gptbot.Similarity, error) {
	// We need to load the collection before searching.
	if err := m.client.LoadCollection(ctx, m.cfg.CollectionName, false); err != nil {
		return nil, err
	}

	float32Emb := xslices.Float64ToNumber[float32](embedding)
	vec2search := []entity.Vector{
		entity.FloatVector(float32Emb),
	}

	param, _ := entity.NewIndexFlatSearchParam()
	result, err := m.client.Search(
		ctx,
		m.cfg.CollectionName,
		nil,
		"",
		[]string{idName, textName, documentIDName},
		vec2search,
		embeddingName,
		entity.L2,
		topK,
		param,
	)
	if err != nil {
		return nil, err
	}

	return constructSimilaritiesFromResult(&result[0])
}

func (m *Milvus) createCollectionIfNotExists(ctx context.Context) error {
	has, err := m.client.HasCollection(ctx, m.cfg.CollectionName)
	if err != nil {
		return err
	}

	if has {
		//_ = m.client.DropCollection(ctx, m.cfg.CollectionName)
		return nil
	}

	// The collection does not exist, so we need to create one.

	schema := &entity.Schema{
		CollectionName: m.cfg.CollectionName,
		AutoID:         true,
		Fields: []*entity.Field{
			{
				Name:       pkName,
				DataType:   entity.FieldTypeInt64,
				PrimaryKey: true,
				AutoID:     true,
			},
			{
				Name:     idName,
				DataType: entity.FieldTypeVarChar,
				TypeParams: map[string]string{
					entity.TypeParamMaxLength: fmt.Sprintf("%d", 65535),
				},
			},
			{
				Name:     textName,
				DataType: entity.FieldTypeVarChar,
				TypeParams: map[string]string{
					entity.TypeParamMaxLength: fmt.Sprintf("%d", 65535),
				},
			},
			{
				Name:     documentIDName,
				DataType: entity.FieldTypeVarChar,
				TypeParams: map[string]string{
					entity.TypeParamMaxLength: fmt.Sprintf("%d", 65535),
				},
			},
			{
				Name:     embeddingName,
				DataType: entity.FieldTypeFloatVector,
				TypeParams: map[string]string{
					entity.TypeParamDim: fmt.Sprintf("%d", m.cfg.Dim),
				},
			},
		},
	}

	// Create collection with consistency level, which serves as the default search/query consistency level.
	return m.client.CreateCollection(ctx, schema, 2, client.WithConsistencyLevel(entity.ClBounded))
}

func constructSimilaritiesFromResult(result *client.SearchResult) ([]*gptbot.Similarity, error) {
	var idCol *entity.ColumnVarChar
	var textCol *entity.ColumnVarChar
	var documentIDCol *entity.ColumnVarChar
	for _, field := range result.Fields {
		switch field.Name() {
		case idName:
			if c, ok := field.(*entity.ColumnVarChar); ok {
				idCol = c
			}
		case textName:
			if c, ok := field.(*entity.ColumnVarChar); ok {
				textCol = c
			}
		case documentIDName:
			if c, ok := field.(*entity.ColumnVarChar); ok {
				documentIDCol = c
			}
		}
	}

	var similarities []*gptbot.Similarity
	for i := 0; i < result.ResultCount; i++ {
		id, err := idCol.ValueByIdx(i)
		if err != nil {
			return nil, err
		}
		text, err := textCol.ValueByIdx(i)
		if err != nil {
			return nil, err
		}
		documentID, err := documentIDCol.ValueByIdx(i)
		if err != nil {
			return nil, err
		}

		similarities = append(similarities, &gptbot.Similarity{
			Chunk: &gptbot.Chunk{
				ID:         id,
				Text:       text,
				DocumentID: documentID,
			},
			Score: float64(result.Scores[i]),
		})
	}

	return similarities, nil
}
